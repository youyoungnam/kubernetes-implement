## Volume
- 파드 내부의 각 컨테이너는 고유하게 분리된 파일시스템이 존재한다. 왜냐하면 파일시스템은 각 이미지에서 제공되기 때문이다. 만약에 컨테이너가 죽었다가 살아나게 된다면, 컨테이너가 이전에 실행했던 파일시스템의 어떤 파일들을 볼 수 없다.
- 그러나 우리는 실제로 물리 머신에서처럼 새로운 컨테이너가 다시 나와도 이전 데이터가 그대로 보존되고 싶을 때 가 있다. 그럴 때 사용하는게 볼륨이다.

### Volume LifeCycle
- 쿠버네티스 스토리지 볼륨은 파드의 일부분으로 정의 되며 파드와 동일한 라이프사이클을 가진다. 즉, 파드가 시작되면 볼륨이 실행되고 파드가 삭제되면 볼륨이 삭제된다는 것을 의미한다. 이 때문에 볼륨의 콘텐츠는 컨테이너를 다시 시작해도 지속된다. 즉, 컨테이너가 다시 시작되면 새로운 컨테이너는 이전 컨테이너가 볼륨에 기록한 모든 파일들을 볼 수 있다. 

## Volume Type
- emptyDir: 일시적인 데이터를 저장하는 데 사용되는 간단한 빈 디렉토리
- hostPath: 워커 노드의 파일시스템을 파드의 디렉토리로 마운트하는 데 사용
- gitRepo: 깃 레포지토리의 콘텐츠를 체크아웃해 초기화한 볼륨
- nfs: NFS 공유를 파드에 마운트
- gcePersistentDisk, awsElasticBlockStore, azureDisk: 클라우드 제공자의 전용 스토리지를 마운트
- cinder, cephfs, iscsi, flocker, glusterfs, qusterfs, quobyte, rbd, flexVloume, vsphere Volume, photonPersistentDisk, scaleIO: 다른 유형의 네트워크 스토리지 마운트
- configmap, secret, downwareAPI: 쿠버네티스 리소스 및 클러스터 정보 노출하는 데 사용하는 특별한 유형의 볼륨
- persistentVolumeClaim: 사전에 혹은 동적으로 프로비저닝된 퍼시스턴트 스토리지 사용 방법

단일 파드는 동시에 여러 유형의 여러 볼륨을 사용할 수 있다. 파드의 각 컨테이너는 볼륨을 마운트할 수 있고 하지 않을 수 있다. 

emptyDir은 파드를 호스팅하는 워커 노드의 실제 디스크에 생성된다. gitRepo 볼륨은 기본적으로 emptyDir 볼륨이며 파드가 시작되면(container가 생성되기 전) git 레포지토리를 복제하고 특정 리비전을 checkout해 데이터를 채운다.

1. 개발자가 git 레포지토리를 가진 파드를 생성한다. 
2. 쿠버네티스는 빈 디렉토리를 생성하고 특정 git 레포지토리를 복제한다.
3. 파드의 컨테이너가 마운트 경로에 볼륨이 마운트된 상태에서 시작한다.

단점 매번 git 레포지토리에 변경이 일어나고 그것을 파드에 있는 컨테이너에 적용되길 원한다면, 아마도 파드를 매번 지워줘야한다.  git 레포지토리의 볼륨이 생성된 후에는 레포지토리와 동기화하지 않는다는 것이다. 그리고 쿠버네티스 1.27버전부터 볼륨유형에서 사용되지 않는다. 자세한 내용은 공식문서를 확인하면 다른 방식으로 접근할 수 있다.
만약에 git 레포지토리를 마운트하고 파드에 동기화를 해주길 원한다면 사이트카 방식으로 git sync이미지를 사용하여 동기화를 할 수 있는 방식이 있다. 


hostpath 볼륨은 노드 파일시스템의 특정 파일이나 디렉토리를 가리킨다. 동일 노드에 실행 중인 파드가 hostpath 볼륨의 동일 경로를 사용 중이면 동일한 파일이 표시된다.
hostpath 볼륨의 콘텐츠는 파드가 죽으면 삭제되는 반면 hostpath 볼륨의 콘텐츠는 삭제되지 않는다. 즉, 파드가 삭제되면 다음 파드가 호스트의 동일 경로를 가리키는 hostpath 볼륨을 사용하고 이전 파드와 동일한 노드에 스케줄링된다는 조건에서 새로운 파드는 이전 파드가 남긴 모든 항목을 볼 수 있다.
![image](https://github.com/youyoungnam/kubernetes-implement/assets/60678531/067f48fc-2008-4dff-bf92-3fd7353e8353)
