# 쿠버네티스와 같은 시스템이 필요한 이유
- 예전에는 애플리케이션이 거대한 모놀리스 방식으로 개발되었다. 즉, 이러한 거대한 모놀리스 애플리케이션이 작은 마이크로 서비스로 세분화함과 동시에 해당 애플리케이션을 실행하는 인프라의 변경으로 인한 것이다. 

## 거대한 애플리케이션에서 마이크로서비스로 전환
- 모놀리스 애플리케이션은 모든것이 강결합 되어있다. 모든것이 강결합 되어있다는건 어떤 의미일까? 예를들어 어떤 인증 컴포넌트가 있다고 가정해보자 이러한 인증 컴포넌트는 다른곳에서도 사용중하고 있을 가능성이 높다 만약 다른 기능이 변경된다면 인증 컴포넌트도 변경될 수 도 있다. 이런식으로 결합이되어 있다는 의미로 알고 있으면 될거 같다. 그리고 인증부부만 변경 했는데 다른부분까지 다 한번에 재 배포를 해야하는 상황이 온다. 이런식으로 개발을 진행한다면 상호의존성의 제약이 커지고 전체 시스템의 복잡도가 높아질 것이다. 
- 이러한 복잡한 모놀리스 애플리케이션을 마이크로 서비스라는 독립적으로 배포할 수 있는 작은 구성 요소로 분할해야 한다. 각 마이크로 서비스는 독립적인 프로세스로 실행되며 단순하고 잘 정의돈 인터페이스로 다른 마이크로 서비스와 통신한다.
  - 생각해보면 회사에서도 쿠버네티스로 서비스를 운영중이다. 몸으로 느끼는 단점은 각각에 대한 애플리케이션에 대한 CI/CD를 구축해야한다는 점이다. 즉 애플리케이션이 추가될 때 마다 CI/CD가 추가된다는 점이다. 모놀리스 서비스는 하나의 CI/CD만 구축하면 되는데 마이크로 서비스는 각각에 대한 CI/CD를 구축해야 한다는 점이 존재한다. 
  - 그리고 뭔가 서비스 처럼 돌아가게 만들려면 누군가는 서비스에 대해 제대로 알고 있어야 한다는 점이다. 예를들어 프론트엔드를 마이크로 서비스로 구축했다면, 메인 서비스에서 다른 마이크로 서비스들을 호출 할 수 있게 엔드포인트 설정을 해줘야 할 것이다. 
  - 개발 이외에도 협업 즉, 소통이 중요하다. 사람들은 자기만의 성격이나 생각을 가지고 있기 때문에 여러가지 문제가 생길 수 있다..
  

## 컨테이너
- 컨테이너 내부를 알고 사용하자. 컨테이너가 동작할 수 있는 이유는 첫 번째는 리눅스 네임스페이스로 각 프로세스가 시스템에 대한 독립된 뷰를 볼 수 있어서다.그렇다면 네임스페이스란 무엇일까?
  - 마운트(mnt)
  - 프로세스ID(pid)
  - 네트워크(net)
  - 프로세스 간 통신(ipc)
  - 호스트와 도메인 이름(uts)
  - 사용자 ID(users)
- 기본적으로 리눅스 시스템은 초기 시작할 때 하나의 네임스페이스가 존재하고 파일시스템, 프로세스, 사용자 네트워크 인터페이스 등과 같은 모든 시스템 리소스는 하나의 네임스페이스에 속한다. 프로세스는 동일한 네임스페이스 내에 있는 리소스만 볼 수 있다. 
- 두 번째는 Cgroups 프로세스가 사용할 수 있는 리소스의 양을 제한할 수 있다.
  - cpu
  - memory
  - network

## 도커 컨테이너 등장
- 컨테이너 기술은 오랫동안 사용돼 왔지만, 도커 칸테이너가 등장으로 널리 알려지게 된것이다. 여러 시스템에 쉽게 이식이 가능하게 하는 최초의 시스템인것이다. 
- 애플리케이션 배포에 필요한 라이브러리, 종속성 등등 도커를 실행하는 다른 컴퓨터에 애플리케이션을 배포하는데 사용할 수 있는 것이다. 


## 도커 이미지 레이어 
- 도커 이미지는 레이어로 구성돼어 있다. 모든 도커 이미지는 다른 이미지 위에 빌드되고 두 개의 다른 이미지는 기본 이미지로 동일한 부모 이미지를 사용할 수 있다. 다른 이미지에는 정확히 동일한 레이어가 포함될 수 있다. 
  - 첫 번째 이미지의 일부로 전송한 레이어를 다른 이미지를 전송할 때 다시 전송할 필요가 없기 때문에 네트워크로 이미지를 배포하는 속도가 빨라진다. 
- 도커 이미지 레이어는 배포를 효율적으로 할 뿐만 아니라 이미지의 스토리지 공간을 줄이는 데 도움된다. 각 레이어는 동일 호스트에 한 번만 저장된다. 
- 주의할 점 도커는 도커 자체가 프로세스를 격리하는게 아니다. 컨테이너 격리는 리눅스의 네임스페이스 기술과 cgroup과 같은 커널 수준에서 수행되는 것이다.


## 쿠버네티스 등장
- 쿠버네티스는 오랜 세월 동안 구글 보그 --> 오메가로 변경된 시스템이라는 내부 시스템을 개발해 애플리케이션 개발자와 시스템 관리자가 수천 개의 애플리케이션과 서비스를 관리하는 데 도움을 줬다. 수십만 대의 머신을 우녕할 때, 사용률이 조그만 향상돼도 수백만 달러가 절약되므로 이러한 시스템을 개발할 동기는 분명하다. 구글은 10년동안 보그와 오메가를 비밀로 유지하고 2014년 보그 오메가 내부 구글 시스템으로 얻은 경험 기반으로 쿠버네티스를 출시했다. 
  - 아마도 구글같은 큰 기업은 서비스가 적어도 수천개의 컨테이너가 존재했을 거다. 이러한 컨테이너 운영하는데 힘든점이 있을 가능성이 높았을거 같다. 진짜 상상도 안된다. 그냥 도커 컨테이너 10개만 해도 운영하기가 힘들텐데 이런게 수천개가 있다고 생각하니 끔찍하다. 
  - 구글은 아마도 내부에서는 쿠버네티스 이상의 기술을 가지고 있을거 같다.


## 쿠버네티스가 Yaml(디스크립션) 실행하는 방법
- kubernetes api 서버가 애플리케이션 디스크립션을 처리할 때 스케줄러(컨트롤 플레인 포함되어 있음) 각 컨테이너에 필요한 리소스를 계산하고 해당 시점에 각 노드에 할당되지 않은 리소스를 기반으로 사용 가능한 Worker Node에 지정된 컨테이너를 할당한다 그런다음 kubelet(워커노드에 존재)은 컨테이너 런타임에 필요한 컨테이너 이미지를 가져와서 컨테이너를 실행하도록 지시한다. 
  - 만약에 하나의 파드에 두개의 컨테이너가 있다면 해당 컨테이너들은 같은 노드에 배치될것이다. 이 컨테이너들이 따로 배치되서는 안된다.


![image](https://github.com/youyoungnam/kubernetes-implement/assets/60678531/4b9a982d-9fc0-437b-8466-42ab98b32740)
